// Code generated by SQLBoiler 4.16.2 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// Domain is an object representing the database table.
type Domain struct {
	ID           int64       `boil:"id" json:"id" toml:"id" yaml:"id"`
	Domain       string      `boil:"domain" json:"domain" toml:"domain" yaml:"domain"`
	Description  null.String `boil:"description" json:"description,omitempty" toml:"description" yaml:"description,omitempty"`
	MaxAliases   int         `boil:"max_aliases" json:"max_aliases" toml:"max_aliases" yaml:"max_aliases"`
	AliasCount   int64       `boil:"alias_count" json:"alias_count" toml:"alias_count" yaml:"alias_count"`
	MaxMailboxes int         `boil:"max_mailboxes" json:"max_mailboxes" toml:"max_mailboxes" yaml:"max_mailboxes"`
	MailboxCount int64       `boil:"mailbox_count" json:"mailbox_count" toml:"mailbox_count" yaml:"mailbox_count"`
	MaxQuota     int64       `boil:"max_quota" json:"max_quota" toml:"max_quota" yaml:"max_quota"`
	Quota        int64       `boil:"quota" json:"quota" toml:"quota" yaml:"quota"`
	Transport    string      `boil:"transport" json:"transport" toml:"transport" yaml:"transport"`
	Backupmx     bool        `boil:"backupmx" json:"backupmx" toml:"backupmx" yaml:"backupmx"`
	Active       bool        `boil:"active" json:"active" toml:"active" yaml:"active"`
	Homedir      null.String `boil:"homedir" json:"homedir,omitempty" toml:"homedir" yaml:"homedir,omitempty"`
	Maildir      null.String `boil:"maildir" json:"maildir,omitempty" toml:"maildir" yaml:"maildir,omitempty"`
	UID          null.Int    `boil:"uid" json:"uid,omitempty" toml:"uid" yaml:"uid,omitempty"`
	Gid          null.Int    `boil:"gid" json:"gid,omitempty" toml:"gid" yaml:"gid,omitempty"`
	Created      time.Time   `boil:"created" json:"created" toml:"created" yaml:"created"`
	Modified     null.Time   `boil:"modified" json:"modified,omitempty" toml:"modified" yaml:"modified,omitempty"`

	R *domainR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L domainL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var DomainColumns = struct {
	ID           string
	Domain       string
	Description  string
	MaxAliases   string
	AliasCount   string
	MaxMailboxes string
	MailboxCount string
	MaxQuota     string
	Quota        string
	Transport    string
	Backupmx     string
	Active       string
	Homedir      string
	Maildir      string
	UID          string
	Gid          string
	Created      string
	Modified     string
}{
	ID:           "id",
	Domain:       "domain",
	Description:  "description",
	MaxAliases:   "max_aliases",
	AliasCount:   "alias_count",
	MaxMailboxes: "max_mailboxes",
	MailboxCount: "mailbox_count",
	MaxQuota:     "max_quota",
	Quota:        "quota",
	Transport:    "transport",
	Backupmx:     "backupmx",
	Active:       "active",
	Homedir:      "homedir",
	Maildir:      "maildir",
	UID:          "uid",
	Gid:          "gid",
	Created:      "created",
	Modified:     "modified",
}

var DomainTableColumns = struct {
	ID           string
	Domain       string
	Description  string
	MaxAliases   string
	AliasCount   string
	MaxMailboxes string
	MailboxCount string
	MaxQuota     string
	Quota        string
	Transport    string
	Backupmx     string
	Active       string
	Homedir      string
	Maildir      string
	UID          string
	Gid          string
	Created      string
	Modified     string
}{
	ID:           "domain.id",
	Domain:       "domain.domain",
	Description:  "domain.description",
	MaxAliases:   "domain.max_aliases",
	AliasCount:   "domain.alias_count",
	MaxMailboxes: "domain.max_mailboxes",
	MailboxCount: "domain.mailbox_count",
	MaxQuota:     "domain.max_quota",
	Quota:        "domain.quota",
	Transport:    "domain.transport",
	Backupmx:     "domain.backupmx",
	Active:       "domain.active",
	Homedir:      "domain.homedir",
	Maildir:      "domain.maildir",
	UID:          "domain.uid",
	Gid:          "domain.gid",
	Created:      "domain.created",
	Modified:     "domain.modified",
}

// Generated where

type whereHelperint struct{ field string }

func (w whereHelperint) EQ(x int) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperint) NEQ(x int) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperint) LT(x int) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperint) LTE(x int) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperint) GT(x int) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperint) GTE(x int) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }
func (w whereHelperint) IN(slice []int) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelperint) NIN(slice []int) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

type whereHelpernull_Int struct{ field string }

func (w whereHelpernull_Int) EQ(x null.Int) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Int) NEQ(x null.Int) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Int) LT(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Int) LTE(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Int) GT(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Int) GTE(x null.Int) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}
func (w whereHelpernull_Int) IN(slice []int) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelpernull_Int) NIN(slice []int) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

func (w whereHelpernull_Int) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Int) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

var DomainWhere = struct {
	ID           whereHelperint64
	Domain       whereHelperstring
	Description  whereHelpernull_String
	MaxAliases   whereHelperint
	AliasCount   whereHelperint64
	MaxMailboxes whereHelperint
	MailboxCount whereHelperint64
	MaxQuota     whereHelperint64
	Quota        whereHelperint64
	Transport    whereHelperstring
	Backupmx     whereHelperbool
	Active       whereHelperbool
	Homedir      whereHelpernull_String
	Maildir      whereHelpernull_String
	UID          whereHelpernull_Int
	Gid          whereHelpernull_Int
	Created      whereHelpertime_Time
	Modified     whereHelpernull_Time
}{
	ID:           whereHelperint64{field: "`domain`.`id`"},
	Domain:       whereHelperstring{field: "`domain`.`domain`"},
	Description:  whereHelpernull_String{field: "`domain`.`description`"},
	MaxAliases:   whereHelperint{field: "`domain`.`max_aliases`"},
	AliasCount:   whereHelperint64{field: "`domain`.`alias_count`"},
	MaxMailboxes: whereHelperint{field: "`domain`.`max_mailboxes`"},
	MailboxCount: whereHelperint64{field: "`domain`.`mailbox_count`"},
	MaxQuota:     whereHelperint64{field: "`domain`.`max_quota`"},
	Quota:        whereHelperint64{field: "`domain`.`quota`"},
	Transport:    whereHelperstring{field: "`domain`.`transport`"},
	Backupmx:     whereHelperbool{field: "`domain`.`backupmx`"},
	Active:       whereHelperbool{field: "`domain`.`active`"},
	Homedir:      whereHelpernull_String{field: "`domain`.`homedir`"},
	Maildir:      whereHelpernull_String{field: "`domain`.`maildir`"},
	UID:          whereHelpernull_Int{field: "`domain`.`uid`"},
	Gid:          whereHelpernull_Int{field: "`domain`.`gid`"},
	Created:      whereHelpertime_Time{field: "`domain`.`created`"},
	Modified:     whereHelpernull_Time{field: "`domain`.`modified`"},
}

// DomainRels is where relationship names are stored.
var DomainRels = struct {
	Admins          string
	DomainMailboxes string
}{
	Admins:          "Admins",
	DomainMailboxes: "DomainMailboxes",
}

// domainR is where relationships are stored.
type domainR struct {
	Admins          AdminSlice   `boil:"Admins" json:"Admins" toml:"Admins" yaml:"Admins"`
	DomainMailboxes MailboxSlice `boil:"DomainMailboxes" json:"DomainMailboxes" toml:"DomainMailboxes" yaml:"DomainMailboxes"`
}

// NewStruct creates a new relationship struct
func (*domainR) NewStruct() *domainR {
	return &domainR{}
}

func (r *domainR) GetAdmins() AdminSlice {
	if r == nil {
		return nil
	}
	return r.Admins
}

func (r *domainR) GetDomainMailboxes() MailboxSlice {
	if r == nil {
		return nil
	}
	return r.DomainMailboxes
}

// domainL is where Load methods for each relationship are stored.
type domainL struct{}

var (
	domainAllColumns            = []string{"id", "domain", "description", "max_aliases", "alias_count", "max_mailboxes", "mailbox_count", "max_quota", "quota", "transport", "backupmx", "active", "homedir", "maildir", "uid", "gid", "created", "modified"}
	domainColumnsWithoutDefault = []string{"domain", "description", "max_aliases", "alias_count", "max_mailboxes", "mailbox_count", "max_quota", "quota", "transport", "backupmx", "active", "homedir", "maildir", "uid", "gid", "created", "modified"}
	domainColumnsWithDefault    = []string{"id"}
	domainPrimaryKeyColumns     = []string{"id"}
	domainGeneratedColumns      = []string{}
)

type (
	// DomainSlice is an alias for a slice of pointers to Domain.
	// This should almost always be used instead of []Domain.
	DomainSlice []*Domain
	// DomainHook is the signature for custom Domain hook methods
	DomainHook func(context.Context, boil.ContextExecutor, *Domain) error

	domainQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	domainType                 = reflect.TypeOf(&Domain{})
	domainMapping              = queries.MakeStructMapping(domainType)
	domainPrimaryKeyMapping, _ = queries.BindMapping(domainType, domainMapping, domainPrimaryKeyColumns)
	domainInsertCacheMut       sync.RWMutex
	domainInsertCache          = make(map[string]insertCache)
	domainUpdateCacheMut       sync.RWMutex
	domainUpdateCache          = make(map[string]updateCache)
	domainUpsertCacheMut       sync.RWMutex
	domainUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var domainAfterSelectMu sync.Mutex
var domainAfterSelectHooks []DomainHook

var domainBeforeInsertMu sync.Mutex
var domainBeforeInsertHooks []DomainHook
var domainAfterInsertMu sync.Mutex
var domainAfterInsertHooks []DomainHook

var domainBeforeUpdateMu sync.Mutex
var domainBeforeUpdateHooks []DomainHook
var domainAfterUpdateMu sync.Mutex
var domainAfterUpdateHooks []DomainHook

var domainBeforeDeleteMu sync.Mutex
var domainBeforeDeleteHooks []DomainHook
var domainAfterDeleteMu sync.Mutex
var domainAfterDeleteHooks []DomainHook

var domainBeforeUpsertMu sync.Mutex
var domainBeforeUpsertHooks []DomainHook
var domainAfterUpsertMu sync.Mutex
var domainAfterUpsertHooks []DomainHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *Domain) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range domainAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *Domain) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range domainBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *Domain) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range domainAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *Domain) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range domainBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *Domain) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range domainAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *Domain) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range domainBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *Domain) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range domainAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *Domain) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range domainBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *Domain) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range domainAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddDomainHook registers your hook function for all future operations.
func AddDomainHook(hookPoint boil.HookPoint, domainHook DomainHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		domainAfterSelectMu.Lock()
		domainAfterSelectHooks = append(domainAfterSelectHooks, domainHook)
		domainAfterSelectMu.Unlock()
	case boil.BeforeInsertHook:
		domainBeforeInsertMu.Lock()
		domainBeforeInsertHooks = append(domainBeforeInsertHooks, domainHook)
		domainBeforeInsertMu.Unlock()
	case boil.AfterInsertHook:
		domainAfterInsertMu.Lock()
		domainAfterInsertHooks = append(domainAfterInsertHooks, domainHook)
		domainAfterInsertMu.Unlock()
	case boil.BeforeUpdateHook:
		domainBeforeUpdateMu.Lock()
		domainBeforeUpdateHooks = append(domainBeforeUpdateHooks, domainHook)
		domainBeforeUpdateMu.Unlock()
	case boil.AfterUpdateHook:
		domainAfterUpdateMu.Lock()
		domainAfterUpdateHooks = append(domainAfterUpdateHooks, domainHook)
		domainAfterUpdateMu.Unlock()
	case boil.BeforeDeleteHook:
		domainBeforeDeleteMu.Lock()
		domainBeforeDeleteHooks = append(domainBeforeDeleteHooks, domainHook)
		domainBeforeDeleteMu.Unlock()
	case boil.AfterDeleteHook:
		domainAfterDeleteMu.Lock()
		domainAfterDeleteHooks = append(domainAfterDeleteHooks, domainHook)
		domainAfterDeleteMu.Unlock()
	case boil.BeforeUpsertHook:
		domainBeforeUpsertMu.Lock()
		domainBeforeUpsertHooks = append(domainBeforeUpsertHooks, domainHook)
		domainBeforeUpsertMu.Unlock()
	case boil.AfterUpsertHook:
		domainAfterUpsertMu.Lock()
		domainAfterUpsertHooks = append(domainAfterUpsertHooks, domainHook)
		domainAfterUpsertMu.Unlock()
	}
}

// One returns a single domain record from the query.
func (q domainQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Domain, error) {
	o := &Domain{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for domain")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all Domain records from the query.
func (q domainQuery) All(ctx context.Context, exec boil.ContextExecutor) (DomainSlice, error) {
	var o []*Domain

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to Domain slice")
	}

	if len(domainAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all Domain records in the query.
func (q domainQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count domain rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q domainQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if domain exists")
	}

	return count > 0, nil
}

// Admins retrieves all the admin's Admins with an executor.
func (o *Domain) Admins(mods ...qm.QueryMod) adminQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.InnerJoin("`domain_admins` on `admin`.`id` = `domain_admins`.`Admin_id`"),
		qm.Where("`domain_admins`.`Domain_id`=?", o.ID),
	)

	return Admins(queryMods...)
}

// DomainMailboxes retrieves all the mailbox's Mailboxes with an executor via Domain_id column.
func (o *Domain) DomainMailboxes(mods ...qm.QueryMod) mailboxQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("`mailbox`.`Domain_id`=?", o.ID),
	)

	return Mailboxes(queryMods...)
}

// LoadAdmins allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (domainL) LoadAdmins(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDomain interface{}, mods queries.Applicator) error {
	var slice []*Domain
	var object *Domain

	if singular {
		var ok bool
		object, ok = maybeDomain.(*Domain)
		if !ok {
			object = new(Domain)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDomain)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDomain))
			}
		}
	} else {
		s, ok := maybeDomain.(*[]*Domain)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDomain)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDomain))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &domainR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &domainR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.Select("`admin`.`id`, `admin`.`username`, `admin`.`password`, `admin`.`super`, `admin`.`active`, `admin`.`created`, `admin`.`modified`, `a`.`Domain_id`"),
		qm.From("`admin`"),
		qm.InnerJoin("`domain_admins` as `a` on `admin`.`id` = `a`.`Admin_id`"),
		qm.WhereIn("`a`.`Domain_id` in ?", argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load admin")
	}

	var resultSlice []*Admin

	var localJoinCols []int64
	for results.Next() {
		one := new(Admin)
		var localJoinCol int64

		err = results.Scan(&one.ID, &one.Username, &one.Password, &one.Super, &one.Active, &one.Created, &one.Modified, &localJoinCol)
		if err != nil {
			return errors.Wrap(err, "failed to scan eager loaded results for admin")
		}
		if err = results.Err(); err != nil {
			return errors.Wrap(err, "failed to plebian-bind eager loaded slice admin")
		}

		resultSlice = append(resultSlice, one)
		localJoinCols = append(localJoinCols, localJoinCol)
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on admin")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for admin")
	}

	if len(adminAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.Admins = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &adminR{}
			}
			foreign.R.Domains = append(foreign.R.Domains, object)
		}
		return nil
	}

	for i, foreign := range resultSlice {
		localJoinCol := localJoinCols[i]
		for _, local := range slice {
			if local.ID == localJoinCol {
				local.R.Admins = append(local.R.Admins, foreign)
				if foreign.R == nil {
					foreign.R = &adminR{}
				}
				foreign.R.Domains = append(foreign.R.Domains, local)
				break
			}
		}
	}

	return nil
}

// LoadDomainMailboxes allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (domainL) LoadDomainMailboxes(ctx context.Context, e boil.ContextExecutor, singular bool, maybeDomain interface{}, mods queries.Applicator) error {
	var slice []*Domain
	var object *Domain

	if singular {
		var ok bool
		object, ok = maybeDomain.(*Domain)
		if !ok {
			object = new(Domain)
			ok = queries.SetFromEmbeddedStruct(&object, &maybeDomain)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybeDomain))
			}
		}
	} else {
		s, ok := maybeDomain.(*[]*Domain)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybeDomain)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybeDomain))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &domainR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &domainR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`mailbox`),
		qm.WhereIn(`mailbox.Domain_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load mailbox")
	}

	var resultSlice []*Mailbox
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice mailbox")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on mailbox")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for mailbox")
	}

	if len(mailboxAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.DomainMailboxes = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &mailboxR{}
			}
			foreign.R.Domain = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.DomainID) {
				local.R.DomainMailboxes = append(local.R.DomainMailboxes, foreign)
				if foreign.R == nil {
					foreign.R = &mailboxR{}
				}
				foreign.R.Domain = local
				break
			}
		}
	}

	return nil
}

// AddAdmins adds the given related objects to the existing relationships
// of the domain, optionally inserting them as new records.
// Appends related to o.R.Admins.
// Sets related.R.Domains appropriately.
func (o *Domain) AddAdmins(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Admin) error {
	var err error
	for _, rel := range related {
		if insert {
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		}
	}

	for _, rel := range related {
		query := "insert into `domain_admins` (`Domain_id`, `Admin_id`) values (?, ?)"
		values := []interface{}{o.ID, rel.ID}

		if boil.IsDebug(ctx) {
			writer := boil.DebugWriterFrom(ctx)
			fmt.Fprintln(writer, query)
			fmt.Fprintln(writer, values)
		}
		_, err = exec.ExecContext(ctx, query, values...)
		if err != nil {
			return errors.Wrap(err, "failed to insert into join table")
		}
	}
	if o.R == nil {
		o.R = &domainR{
			Admins: related,
		}
	} else {
		o.R.Admins = append(o.R.Admins, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &adminR{
				Domains: DomainSlice{o},
			}
		} else {
			rel.R.Domains = append(rel.R.Domains, o)
		}
	}
	return nil
}

// SetAdmins removes all previously related items of the
// domain replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Domains's Admins accordingly.
// Replaces o.R.Admins with related.
// Sets related.R.Domains's Admins accordingly.
func (o *Domain) SetAdmins(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Admin) error {
	query := "delete from `domain_admins` where `Domain_id` = ?"
	values := []interface{}{o.ID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	removeAdminsFromDomainsSlice(o, related)
	if o.R != nil {
		o.R.Admins = nil
	}

	return o.AddAdmins(ctx, exec, insert, related...)
}

// RemoveAdmins relationships from objects passed in.
// Removes related items from R.Admins (uses pointer comparison, removal does not keep order)
// Sets related.R.Domains.
func (o *Domain) RemoveAdmins(ctx context.Context, exec boil.ContextExecutor, related ...*Admin) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	query := fmt.Sprintf(
		"delete from `domain_admins` where `Domain_id` = ? and `Admin_id` in (%s)",
		strmangle.Placeholders(dialect.UseIndexPlaceholders, len(related), 2, 1),
	)
	values := []interface{}{o.ID}
	for _, rel := range related {
		values = append(values, rel.ID)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err = exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}
	removeAdminsFromDomainsSlice(o, related)
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.Admins {
			if rel != ri {
				continue
			}

			ln := len(o.R.Admins)
			if ln > 1 && i < ln-1 {
				o.R.Admins[i] = o.R.Admins[ln-1]
			}
			o.R.Admins = o.R.Admins[:ln-1]
			break
		}
	}

	return nil
}

func removeAdminsFromDomainsSlice(o *Domain, related []*Admin) {
	for _, rel := range related {
		if rel.R == nil {
			continue
		}
		for i, ri := range rel.R.Domains {
			if o.ID != ri.ID {
				continue
			}

			ln := len(rel.R.Domains)
			if ln > 1 && i < ln-1 {
				rel.R.Domains[i] = rel.R.Domains[ln-1]
			}
			rel.R.Domains = rel.R.Domains[:ln-1]
			break
		}
	}
}

// AddDomainMailboxes adds the given related objects to the existing relationships
// of the domain, optionally inserting them as new records.
// Appends related to o.R.DomainMailboxes.
// Sets related.R.Domain appropriately.
func (o *Domain) AddDomainMailboxes(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Mailbox) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.DomainID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE `mailbox` SET %s WHERE %s",
				strmangle.SetParamNames("`", "`", 0, []string{"Domain_id"}),
				strmangle.WhereClause("`", "`", 0, mailboxPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.DomainID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &domainR{
			DomainMailboxes: related,
		}
	} else {
		o.R.DomainMailboxes = append(o.R.DomainMailboxes, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &mailboxR{
				Domain: o,
			}
		} else {
			rel.R.Domain = o
		}
	}
	return nil
}

// SetDomainMailboxes removes all previously related items of the
// domain replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Domain's DomainMailboxes accordingly.
// Replaces o.R.DomainMailboxes with related.
// Sets related.R.Domain's DomainMailboxes accordingly.
func (o *Domain) SetDomainMailboxes(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Mailbox) error {
	query := "update `mailbox` set `Domain_id` = null where `Domain_id` = ?"
	values := []interface{}{o.ID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.DomainMailboxes {
			queries.SetScanner(&rel.DomainID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Domain = nil
		}
		o.R.DomainMailboxes = nil
	}

	return o.AddDomainMailboxes(ctx, exec, insert, related...)
}

// RemoveDomainMailboxes relationships from objects passed in.
// Removes related items from R.DomainMailboxes (uses pointer comparison, removal does not keep order)
// Sets related.R.Domain.
func (o *Domain) RemoveDomainMailboxes(ctx context.Context, exec boil.ContextExecutor, related ...*Mailbox) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.DomainID, nil)
		if rel.R != nil {
			rel.R.Domain = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("Domain_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.DomainMailboxes {
			if rel != ri {
				continue
			}

			ln := len(o.R.DomainMailboxes)
			if ln > 1 && i < ln-1 {
				o.R.DomainMailboxes[i] = o.R.DomainMailboxes[ln-1]
			}
			o.R.DomainMailboxes = o.R.DomainMailboxes[:ln-1]
			break
		}
	}

	return nil
}

// Domains retrieves all the records using an executor.
func Domains(mods ...qm.QueryMod) domainQuery {
	mods = append(mods, qm.From("`domain`"))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"`domain`.*"})
	}

	return domainQuery{q}
}

// FindDomain retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindDomain(ctx context.Context, exec boil.ContextExecutor, iD int64, selectCols ...string) (*Domain, error) {
	domainObj := &Domain{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from `domain` where `id`=?", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, domainObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from domain")
	}

	if err = domainObj.doAfterSelectHooks(ctx, exec); err != nil {
		return domainObj, err
	}

	return domainObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Domain) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no domain provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.Created.IsZero() {
			o.Created = currTime
		}
		if queries.MustTime(o.Modified).IsZero() {
			queries.SetScanner(&o.Modified, currTime)
		}
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(domainColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	domainInsertCacheMut.RLock()
	cache, cached := domainInsertCache[key]
	domainInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			domainAllColumns,
			domainColumnsWithDefault,
			domainColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(domainType, domainMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(domainType, domainMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO `domain` (`%s`) %%sVALUES (%s)%%s", strings.Join(wl, "`,`"), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO `domain` () VALUES ()%s%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			cache.retQuery = fmt.Sprintf("SELECT `%s` FROM `domain` WHERE %s", strings.Join(returnColumns, "`,`"), strmangle.WhereClause("`", "`", 0, domainPrimaryKeyColumns))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into domain")
	}

	var lastID int64
	var identifierCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ID = int64(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == domainMapping["id"] {
		goto CacheNoHooks
	}

	identifierCols = []interface{}{
		o.ID,
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, identifierCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, identifierCols...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for domain")
	}

CacheNoHooks:
	if !cached {
		domainInsertCacheMut.Lock()
		domainInsertCache[key] = cache
		domainInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the Domain.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Domain) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		queries.SetScanner(&o.Modified, currTime)
	}

	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	domainUpdateCacheMut.RLock()
	cache, cached := domainUpdateCache[key]
	domainUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			domainAllColumns,
			domainPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update domain, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE `domain` SET %s WHERE %s",
			strmangle.SetParamNames("`", "`", 0, wl),
			strmangle.WhereClause("`", "`", 0, domainPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(domainType, domainMapping, append(wl, domainPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update domain row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for domain")
	}

	if !cached {
		domainUpdateCacheMut.Lock()
		domainUpdateCache[key] = cache
		domainUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q domainQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for domain")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for domain")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o DomainSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), domainPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE `domain` SET %s WHERE %s",
		strmangle.SetParamNames("`", "`", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, domainPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in domain slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all domain")
	}
	return rowsAff, nil
}

var mySQLDomainUniqueColumns = []string{
	"id",
	"domain",
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Domain) Upsert(ctx context.Context, exec boil.ContextExecutor, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no domain provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.Created.IsZero() {
			o.Created = currTime
		}
		queries.SetScanner(&o.Modified, currTime)
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(domainColumnsWithDefault, o)
	nzUniques := queries.NonZeroDefaultSet(mySQLDomainUniqueColumns, o)

	if len(nzUniques) == 0 {
		return errors.New("cannot upsert with a table that cannot conflict on a unique column")
	}

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzUniques {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	domainUpsertCacheMut.RLock()
	cache, cached := domainUpsertCache[key]
	domainUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, _ := insertColumns.InsertColumnSet(
			domainAllColumns,
			domainColumnsWithDefault,
			domainColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			domainAllColumns,
			domainPrimaryKeyColumns,
		)

		if !updateColumns.IsNone() && len(update) == 0 {
			return errors.New("models: unable to upsert domain, could not build update column list")
		}

		ret := strmangle.SetComplement(domainAllColumns, strmangle.SetIntersect(insert, update))

		cache.query = buildUpsertQueryMySQL(dialect, "`domain`", update, insert)
		cache.retQuery = fmt.Sprintf(
			"SELECT %s FROM `domain` WHERE %s",
			strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, ret), ","),
			strmangle.WhereClause("`", "`", 0, nzUniques),
		)

		cache.valueMapping, err = queries.BindMapping(domainType, domainMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(domainType, domainMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	result, err := exec.ExecContext(ctx, cache.query, vals...)

	if err != nil {
		return errors.Wrap(err, "models: unable to upsert for domain")
	}

	var lastID int64
	var uniqueMap []uint64
	var nzUniqueCols []interface{}

	if len(cache.retMapping) == 0 {
		goto CacheNoHooks
	}

	lastID, err = result.LastInsertId()
	if err != nil {
		return ErrSyncFail
	}

	o.ID = int64(lastID)
	if lastID != 0 && len(cache.retMapping) == 1 && cache.retMapping[0] == domainMapping["id"] {
		goto CacheNoHooks
	}

	uniqueMap, err = queries.BindMapping(domainType, domainMapping, nzUniques)
	if err != nil {
		return errors.Wrap(err, "models: unable to retrieve unique values for domain")
	}
	nzUniqueCols = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), uniqueMap)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.retQuery)
		fmt.Fprintln(writer, nzUniqueCols...)
	}
	err = exec.QueryRowContext(ctx, cache.retQuery, nzUniqueCols...).Scan(returns...)
	if err != nil {
		return errors.Wrap(err, "models: unable to populate default values for domain")
	}

CacheNoHooks:
	if !cached {
		domainUpsertCacheMut.Lock()
		domainUpsertCache[key] = cache
		domainUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single Domain record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Domain) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no Domain provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), domainPrimaryKeyMapping)
	sql := "DELETE FROM `domain` WHERE `id`=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from domain")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for domain")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q domainQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no domainQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from domain")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for domain")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o DomainSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(domainBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), domainPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM `domain` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, domainPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from domain slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for domain")
	}

	if len(domainAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Domain) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindDomain(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *DomainSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := DomainSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), domainPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT `domain`.* FROM `domain` WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, domainPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in DomainSlice")
	}

	*o = slice

	return nil
}

// DomainExists checks if the Domain row exists.
func DomainExists(ctx context.Context, exec boil.ContextExecutor, iD int64) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from `domain` where `id`=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if domain exists")
	}

	return exists, nil
}

// Exists checks if the Domain row exists.
func (o *Domain) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return DomainExists(ctx, exec, o.ID)
}
